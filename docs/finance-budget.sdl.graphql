"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

enum BankName {
  HDFC
  SBI
  OTHER
}

enum TenantType {
  PERSONAL
  CLIENT
  DEFAULT
}

type Query {
  """API version of the GraphQL service."""
  apiVersion: String
  """Simple health check; returns a status string if the API is up."""
  healthCheck: String
  """Returns yearly income, expenses, net savings, and transactions."""
  annualReview(year: Int!): AnnualReview!
  """Returns monthly income, expenses, savings, category breakdown, and series."""
  monthlyReview(month: Int!, year: Int!): MonthlyReview!
  """Returns income, expense, and net savings for the given period."""
  aggregateSummary(year: Int!, month: Int): AggregatedSummary!
  """Groups transactions by category with totals for the month."""
  categoryBreakdown(month: Int!, year: Int!): [CategoryGroup!]!
  """Lists transactions filtered by month/year (paged by cursor)."""
  transactions(filters: TransactionsFilter!, cursor: String): TransactionsPage!
  """Lists categories grouped by base type (INCOME/EXPENSES/SAVINGS)."""
  categoriesByBase: [CategoriesByBase!]!
  """Lists supported tenant types available in the system."""
  tenants: [Tenant!]!
  """Lists savings goals with current progress and history."""
  savingsGoals: [SavingsGoal!]!
  """Lists sinking funds, balances, and history for the tenant."""
  sinkingFunds: [SinkingFund!]!
  """Forecasts daily cash flow for the specified month with optional rules."""
  forecastMonth(year: Int!, month: Int!, options: ForecastOptionsInput): ForecastResult!
  """Lists all recurring transactions for the current tenant/user."""
  recurringTransactions: [RecurringTransaction!]!
}

input RegisterInput {
  email: String!
  name: String!
  tenantId: TenantType!
  password: String!
}

type RegisterResponse {
  success: Boolean!
  message: String!
}

input LoginInput {
  email: String!
  tenantId: TenantType!
  password: String!
}

type User {
  email: String!
  name: String!
  tenantId: TenantType!
  isActive: Boolean!
}

type LoginResponse {
  user: User!
  token: String!
}

type Mutation {
  """Creates a new user account for the given tenant."""
  register(input: RegisterInput!): RegisterResponse!
  """Authenticates a user and returns a login token."""
  login(input: LoginInput!): LoginResponse!
  """Adds or syncs transaction category rules for the current tenant."""
  addTransactionCategory: Boolean!
  """Reclassifies a transaction to a new category and returns the updated item."""
  reclassifyTransaction(id: String!, category: String!): ReclassifiedTransaction!
  """Uploads a bank statement file (base64) for processing and import."""
  uploadStatement(input: StatementInput!): Boolean!
  """Creates a recurring transaction definition."""
  createRecurringTransaction(input: CreateRecurringTransactionInput!): RecurringTransaction!
  """Materializes recurring transactions for the given month and returns the count."""
  generateRecurringTransactions(month: Int!, year: Int!): Int!
  """Sets the budget amount for a category in the specified month/year."""
  setBudget(period: PeriodInput!, category: String!, amount: Float!): Budget!
}

type Transaction {
  tenantId: TenantType!
  userId: String!
  transactionId: String!
  bankName: BankName!
  amount: Float!
  balance: Float
  txnDate: String!
  description: String
  category: String
  embedding: [Float!]
  taggedBy: String
  confidence: Float
  type: String
}

type TransactionItem {
  id: String!
  date: String!
  description: String
  amount: Float!
  currency: String!
  category: String
  taggedBy: String
}

type TransactionsPage {
  items: [TransactionItem!]!
  cursor: String
}

type ReclassifiedTransaction {
  id: String!
  category: String!
  taggedBy: String
}

input TransactionsFilter {
  year: Int!
  month: Int!
  bankName: BankName
  category: String
}

type CategoryAmount {
  name: String!
  amount: Float!
}

type ReviewSeriesPoint {
  date: String!
  budget: Float!
  actual: Float!
}

type MonthlyReview {
  totalIncome: Float!
  totalExpenses: Float!
  savings: Float!
  categoryBreakdown: [CategoryAmount!]!
  series: [ReviewSeriesPoint!]!
}

type AnnualReview {
  totalIncome: Float!
  totalExpense: Float!
  netSavings: Float!
  transactions: [Transaction!]!
}

type CategoryGroup {
  category: String!
  totalAmount: Float!
  transactions: [Transaction!]!
}

enum BaseCategory {
  SAVINGS
  EXPENSES
  INCOME
  DEFAULT
}

type CategoriesByBase {
  base: BaseCategory!
  categories: [String!]!
}

type AggregatedSummary {
  totalIncome: Float!
  totalExpense: Float!
  netSavings: Float!
}

input StatementInput {
  bankName: BankName!
  fileName: String!
  contentBase64: String!
}

type Tenant {
  id: TenantType!
  name: String!
}

type SavingsHistoryPoint {
  date: String!
  value: Float!
}

type SavingsGoal {
  id: ID!
  name: String!
  target: Float!
  current: Float!
  deadline: String!
  history: [SavingsHistoryPoint!]!
}

type SinkingFundHistoryPoint {
  date: String!
  value: Float!
}

type SinkingFund {
  id: ID!
  name: String!
  target: Float!
  current: Float!
  monthlyContribution: Float
  deadline: String
  history: [SinkingFundHistoryPoint!]!
}

type ForecastDay {
  date: String!
  inflow: Float!
  outflow: Float!
  net: Float!
  runningBalance: Float
}

enum AlertSeverity {
  info
  warning
  critical
}

type ForecastAlert {
  date: String!
  type: String!
  message: String!
  severity: AlertSeverity!
}

type ForecastResult {
  month: Int!
  year: Int!
  startingBalance: Float!
  endingBalance: Float!
  days: [ForecastDay!]!
  alerts: [ForecastAlert!]!
}

input ForecastOptionsInput {
  startingBalance: Float
  lowBalanceThreshold: Float
  largeExpenseThreshold: Float
}

enum RecurringFrequency {
  monthly
  weekly
  biweekly
  yearly
}

type RecurringTransaction {
  id: String!
  description: String!
  amount: Float!
  category: String
  frequency: RecurringFrequency!
  dayOfMonth: Int
  dayOfWeek: Int
  monthOfYear: Int
  startDate: String!
  endDate: String
  nextRunDate: String
}

input CreateRecurringTransactionInput {
  description: String!
  amount: Float!
  category: String
  frequency: RecurringFrequency!
  dayOfMonth: Int
  dayOfWeek: Int
  monthOfYear: Int
  startDate: String!
  endDate: String
}

type Budget {
  id: String!
  month: Int!
  year: Int!
  category: String!
  amount: Float!
}

input PeriodInput {
  month: Int!
  year: Int!
}
